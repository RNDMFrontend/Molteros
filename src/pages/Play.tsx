import { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { motion } from "framer-motion";
import { Wallet, TrendingUp, TrendingDown, Settings } from "lucide-react";
import { Button } from "@/components/ui/button";

import {
  useAccount,
  useConnect,
  useDisconnect,
  usePublicClient,
  useWalletClient,
  useChainId,
} from "wagmi";
import { injected } from "wagmi/connectors";
import { parseEther } from "viem";

import {
  getTokensFromStorage,
  truncateAddress,
  OPERATOR_ADDRESS,
  type Token,
} from "@/lib/tokens";

import { LineChart, Line, ResponsiveContainer, YAxis } from "recharts";

// -----------------------------
// On-chain config
// -----------------------------
const MARKET_ADDRESS = "0x6bd72070B5dB56a7B2fbaC92a0B3a24D0D8206D9" as const;

const MARKET_ABI = [
  {
    name: "activeRoundIdByToken",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "token", type: "address" }],
    outputs: [{ name: "", type: "uint256" }],
  },
  {
    name: "rounds",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "id", type: "uint256" }],
    outputs: [
      { name: "token", type: "address" },
      { name: "startTime", type: "uint64" },
      { name: "endTime", type: "uint64" },
      { name: "startQuote", type: "uint256" },
      { name: "endQuote", type: "uint256" },
      { name: "upPool", type: "uint256" },
      { name: "downPool", type: "uint256" },
      { name: "settled", type: "bool" },
      { name: "outcome", type: "uint8" },
      { name: "piPick", type: "uint8" },
      { name: "whyHash", type: "bytes32" },
      { name: "confidence", type: "uint8" },
    ],
  },
  {
    name: "betUp",
    type: "function",
    stateMutability: "payable",
    inputs: [{ name: "roundId", type: "uint256" }],
    outputs: [],
  },
  {
    name: "betDown",
    type: "function",
    stateMutability: "payable",
    inputs: [{ name: "roundId", type: "uint256" }],
    outputs: [],
  },
] as const;

// -----------------------------
// UI knobs
// -----------------------------
const FEE_BPS = 500;
const BET_CHIPS = [0.05, 0.1, 0.25, 1];
const POLL_MS = 2000;

// Pure animation chart (not anchored to chain)
const ANIM_TICK_MS = 250;
const ANIM_VOL = 0.015;
const ANIM_DRIFT = 0.0;

// -----------------------------
// Hackathon warning modal (session-based)
// -----------------------------
function HackathonWarningModal({ isConnected }: { isConnected: boolean }) {
  const KEY = "molter_hackathon_warning_ack_session_v1";
  const [open, setOpen] = useState(false);

  useEffect(() => {
    if (!isConnected) return;
    const ack = sessionStorage.getItem(KEY);
    if (!ack) setOpen(true);
  }, [isConnected]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/70 p-4">
      <div className="w-full max-w-2xl rounded-2xl border border-white/10 bg-zinc-950/90 p-6 shadow-2xl backdrop-blur">
        <div className="flex items-start justify-between gap-4">
          <div>
            <div className="text-sm text-zinc-400">Molter OS</div>
            <h2 className="mt-1 text-xl font-semibold tracking-tight">
              Hackathon Demo Warning
            </h2>
          </div>
          <button
            onClick={() => setOpen(false)}
            className="rounded-lg border border-white/10 bg-white/5 px-3 py-1 text-sm text-zinc-200 hover:bg-white/10"
          >
            Close
          </button>
        </div>

        <ol className="mt-4 list-decimal space-y-2 pl-5 text-sm text-zinc-200">
          <li>Experimental prototype; may be unstable.</li>
          <li>Not audited; smart contract risk exists.</li>
          <li>Use small amounts only.</li>
          <li>1-minute rounds are high variance.</li>
          <li>5% operator fee is taken from the pool.</li>
          <li>Auto-claim may trigger wallet prompts.</li>
          <li>RPC/network delays can cause UI lag.</li>
          <li>Pi picks are generated by a local model and can be wrong.</li>
          <li>This is not financial advice.</li>
        </ol>

        <div className="mt-5 flex items-center gap-3">
          <button
            onClick={() => {
              sessionStorage.setItem(KEY, "1");
              setOpen(false);
            }}
            className="rounded-xl bg-white px-4 py-2 text-sm font-semibold text-zinc-950 hover:opacity-90"
          >
            I Understand — Continue
          </button>
          <span className="text-xs text-zinc-500">Stored for this session only.</span>
        </div>
      </div>
    </div>
  );
}

// -----------------------------
// Market view model
// -----------------------------
type MarketState = {
  symbol: string;
  address: `0x${string}`;

  roundId: bigint;
  countdown: number;

  upPool: number;
  downPool: number;

  settled: boolean;
  piPick: "UP" | "DOWN" | null;
  confidence: number;

  priceHistory: { t: number; p: number }[];
};

function toMon(nWei: bigint) {
  return Number(nWei) / 1e18;
}

function MarketCard({
  market,
  onBet,
  walletReady,
  selectedSide,
  selectedAmount,
  setSelectedSide,
  setSelectedAmount,
  clearSelection,
}: {
  market: MarketState;
  onBet: (symbol: string, side: "UP" | "DOWN", amount: number) => Promise<void>;
  walletReady: boolean;
  selectedSide: "UP" | "DOWN" | null;
  selectedAmount: number | null;
  setSelectedSide: (side: "UP" | "DOWN") => void;
  setSelectedAmount: (amt: number) => void;
  clearSelection: () => void;
}) {
  const [busy, setBusy] = useState(false);

  const totalPool = market.upPool + market.downPool;
  const upPct = totalPool > 0 ? ((market.upPool / totalPool) * 100).toFixed(1) : "50.0";
  const downPct = totalPool > 0 ? ((market.downPool / totalPool) * 100).toFixed(1) : "50.0";

  let payoutPreview: string | null = null;
  if (selectedSide && selectedAmount && totalPool > 0) {
    const sidePool =
      selectedSide === "UP"
        ? market.upPool + selectedAmount
        : market.downPool + selectedAmount;
    const total = totalPool + selectedAmount;
    const payout = (selectedAmount / sidePool) * total * (1 - FEE_BPS / 10000);
    payoutPreview = payout.toFixed(3);
  }

  const handleConfirm = async () => {
    if (!selectedSide || !selectedAmount) return;

    setBusy(true);
    try {
      await onBet(market.symbol, selectedSide, selectedAmount);
      clearSelection();
    } catch (e: any) {
      console.log("BET ERROR", e);
      alert(e?.message || "Bet failed");
    } finally {
      setBusy(false);
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="rounded-xl border border-border bg-card/60 backdrop-blur p-3 sm:p-4 flex flex-col gap-2 sm:gap-3"
    >
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <span className="font-bold text-foreground text-lg">{market.symbol}</span>
          <span className="ml-2 text-[10px] text-muted-foreground font-mono">
            {truncateAddress(market.address)}
          </span>
        </div>
        <div className="text-right">
          <div className="text-[10px] text-muted-foreground">
            {market.roundId === 0n ? "No round" : `Round ${market.roundId.toString()}`}
          </div>
          <div className={`text-sm font-mono font-bold ${market.countdown <= 10 ? "text-primary" : "text-foreground"}`}>
            {market.roundId === 0n ? "—" : `${market.countdown}s`}
          </div>
        </div>
      </div>

      {/* Chart (animated only) */}
      <div className="h-16 w-full">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={market.priceHistory}>
            <YAxis domain={["auto", "auto"]} hide />
            <Line type="monotone" dataKey="p" stroke="hsl(350, 80%, 55%)" strokeWidth={1.5} dot={false} />
          </LineChart>
        </ResponsiveContainer>
      </div>

      {/* Pools */}
      <div className="flex justify-between text-xs">
        <div className="flex items-center gap-1">
          <TrendingUp className="w-3 h-3 text-green-400" />
          <span className="text-green-400">{market.upPool.toFixed(2)} MON</span>
          <span className="text-muted-foreground">({upPct}%)</span>
        </div>
        <div className="flex items-center gap-1">
          <TrendingDown className="w-3 h-3 text-red-400" />
          <span className="text-red-400">{market.downPool.toFixed(2)} MON</span>
          <span className="text-muted-foreground">({downPct}%)</span>
        </div>
      </div>

      {/* Pi Pick */}
      {market.piPick && (
        <div className="flex justify-center">
          <span
            className={`text-[10px] px-2 py-0.5 rounded font-semibold ${
              market.piPick === "UP" ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"
            }`}
          >
            Pi Pick: {market.piPick} · {market.confidence}%
          </span>
        </div>
      )}

      {/* Bet UI */}
      {walletReady && market.roundId !== 0n && !market.settled && (
        <>
          <div className="flex gap-2 justify-center flex-wrap">
            {BET_CHIPS.map((chip) => (
              <button
                key={chip}
                onClick={() => setSelectedAmount(chip)}
                className={`text-[11px] px-3 py-1 rounded-full border transition-all ${
                  selectedAmount === chip
                    ? "border-primary bg-primary/20 text-primary"
                    : "border-border text-muted-foreground hover:border-muted"
                }`}
                disabled={busy}
              >
                {chip} MON
              </button>
            ))}
          </div>

          <div className="flex gap-2">
            <Button
              size="sm"
              variant={selectedSide === "UP" ? "default" : "outline"}
              className={`flex-1 text-xs ${selectedSide === "UP" ? "bg-green-600 hover:bg-green-700 border-green-600" : ""}`}
              onClick={() => setSelectedSide("UP")}
              disabled={busy}
            >
              <TrendingUp className="w-3 h-3 mr-1" /> Bet UP
            </Button>
            <Button
              size="sm"
              variant={selectedSide === "DOWN" ? "default" : "outline"}
              className={`flex-1 text-xs ${selectedSide === "DOWN" ? "bg-red-600 hover:bg-red-700 border-red-600" : ""}`}
              onClick={() => setSelectedSide("DOWN")}
              disabled={busy}
            >
              <TrendingDown className="w-3 h-3 mr-1" /> Bet DOWN
            </Button>
          </div>

          {payoutPreview && (
            <div className="text-center text-[11px] text-muted-foreground">
              Est. payout if {selectedSide} wins:{" "}
              <span className="text-foreground font-semibold">{payoutPreview} MON</span>
            </div>
          )}

          {selectedSide && selectedAmount && (
            <Button
              size="sm"
              className="w-full text-xs"
              disabled={busy}
              onClick={handleConfirm}
            >
              {busy ? "Sending…" : `Confirm ${selectedAmount} MON on ${selectedSide}`}
            </Button>
          )}
        </>
      )}

      <div className="text-[10px] text-muted-foreground text-center">
        Fee: 5% · Settlement: permissionless
      </div>
    </motion.div>
  );
}

export default function Play() {
  // Hooks FIRST (avoid TDZ issues)
  const chainId = useChainId();
  const publicClient = usePublicClient();
  const { data: walletClient } = useWalletClient();

  const { address, isConnected } = useAccount();
  const { connect } = useConnect();
  const { disconnect } = useDisconnect();

  // Only allow betting when signer exists + correct chain
  const walletReady = !!walletClient && chainId === 143;

  // Token list fallback (always render)
  const FALLBACK_TOKENS: Token[] = [
    { symbol: "CHOG", address: "0x350035555E10d9AfAF1566AaebfCeD5BA6C27777" },
    { symbol: "emonad", address: "0x81A224F8A62f52BdE942dBF23A56df77A10b7777" },
    { symbol: "Motion", address: "0x91ce820dD39A2B5639251E8c7837998530Fe7777" },
  ] as any;

  const [tokens] = useState<Token[]>(() => {
    const t = getTokensFromStorage();
    return t?.length ? t : FALLBACK_TOKENS;
  });

  const [markets, setMarkets] = useState<MarketState[]>([]);
  const marketsRef = useRef<MarketState[]>([]);
  useEffect(() => { marketsRef.current = markets; }, [markets]);

  const [selection, setSelection] = useState<Record<string, { side?: "UP"|"DOWN"; amount?: number }>>({});
  const [showOperator, setShowOperator] = useState(false);

  // Re-show modal after disconnect
  useEffect(() => {
    if (!isConnected) {
      sessionStorage.removeItem("molter_hackathon_warning_ack_session_v1");
    }
  }, [isConnected]);

  const isOperator = useMemo(
    () => isConnected && !!address && address.toLowerCase() === OPERATOR_ADDRESS.toLowerCase(),
    [isConnected, address]
  );

  // Initialize market cards
  useEffect(() => {
    const init: MarketState[] = tokens.map((t) => ({
      symbol: t.symbol,
      address: t.address as `0x${string}`,
      roundId: 0n,
      countdown: 0,
      upPool: 0,
      downPool: 0,
      endTime: 0,
      settled: false,
      outcome: 0,
      piPick: null,
      confidence: 0,
      priceHistory: [],
    }));
    setMarkets(init);
  }, [tokens]);

  // Poll on-chain rounds/pools
  useEffect(() => {
    if (!publicClient) return;

    async function tick() {
      try {
        const now = Math.floor(Date.now() / 1000);
        const current = marketsRef.current;
        if (!current.length) return;

        const updated = await Promise.all(
          current.map(async (m) => {
            const rid = await publicClient.readContract({
              address: MARKET_ADDRESS,
              abi: MARKET_ABI,
              functionName: "activeRoundIdByToken",
              args: [m.address],
            });

            if (rid === 0n) {
              return { ...m, roundId: 0n, countdown: 0, upPool: 0, downPool: 0, settled: false, outcome: 0, piPick: null, confidence: 0 };
            }

            const r: any = await publicClient.readContract({
              address: MARKET_ADDRESS,
              abi: MARKET_ABI,
              functionName: "rounds",
              args: [rid],
            });

            const endTime = Number(r[2]);
            const countdown = Math.max(0, endTime - now);

            const upPool = toMon(BigInt(r[5]));
            const downPool = toMon(BigInt(r[6]));
            const settled = Boolean(r[7]);
            const outcome = Number(r[8]);
            const piPickNum = Number(r[9]);
            const confidence = Number(r[11]);

            const piPick = piPickNum === 0 ? "UP" : "DOWN";

            return { ...m, roundId: rid, countdown, upPool, downPool, settled, outcome, piPick, confidence };
          })
        );

        setMarkets(updated);
      } catch {
        // ignore transient RPC errors
      }
    }

    tick();
    const id = setInterval(tick, POLL_MS);
    return () => clearInterval(id);
  }, [publicClient]);

  // Animated chart (pure UI)
  useEffect(() => {
    const id = setInterval(() => {
      setMarkets((prev) =>
        prev.map((m) => {
          const now = Date.now();
          const last = m.priceHistory.length
            ? m.priceHistory[m.priceHistory.length - 1].p
            : (0.5 + Math.random() * 2);

          const next = Math.max(0.01, last + (Math.random() - 0.5) * ANIM_VOL + ANIM_DRIFT);
          const nextHist = [...m.priceHistory, { t: now, p: next }].slice(-80);

          return { ...m, priceHistory: nextHist };
        })
      );
    }, ANIM_TICK_MS);

    return () => clearInterval(id);
  }, []);

  // On-chain bet (MetaMask popup happens here)
  const onBet = useCallback(
    async (symbol: string, side: "UP" | "DOWN", amount: number) => {
      if (!walletClient) throw new Error("Signer not ready yet. Reconnect and try again.");
      if (!publicClient) throw new Error("RPC client missing.");
      if (chainId !== 143) throw new Error(`Wrong network (${chainId}). Switch to Monad (143).`);

      const m = marketsRef.current.find((x) => x.symbol === symbol);
      if (!m) throw new Error("Market not found.");

      // Always read latest roundId from chain right before bet
      const roundId = await publicClient.readContract({
        address: MARKET_ADDRESS,
        abi: MARKET_ABI,
        functionName: "activeRoundIdByToken",
        args: [m.address],
      });

      if (roundId === 0n) throw new Error("No active round yet. Wait a few seconds.");

      const fn = side === "UP" ? "betUp" : "betDown";
      const hash = await walletClient.writeContract({
        address: MARKET_ADDRESS,
        abi: MARKET_ABI,
        functionName: fn,
        args: [roundId],
        value: parseEther(String(amount)),
      });

      await publicClient.waitForTransactionReceipt({ hash });
    },
    [walletClient, publicClient, chainId]
  );

  return (
    <div className="min-h-screen bg-background">
      {/* Top bar */}
      <div className="flex items-center justify-between px-4 sm:px-6 py-4 border-b border-border">
        <div className="flex items-center gap-3">
          <h1 className="text-lg font-extrabold tracking-tight text-foreground">
            Molter<span className="text-primary"> OS</span>
          </h1>
          <span className="text-[10px] px-2 py-0.5 rounded-full bg-primary/20 text-primary font-medium">
            In-Play
          </span>
        </div>

        <div className="hidden sm:flex items-center gap-2">
          {isOperator && (
            <button
              onClick={() => setShowOperator(!showOperator)}
              className="p-2 rounded-lg border border-border text-muted-foreground hover:text-foreground transition-colors"
              title="Operator console"
            >
              <Settings className="w-4 h-4" />
            </button>
          )}

          <Button
            size="sm"
            variant={isConnected ? "outline" : "default"}
            onClick={() => (isConnected ? disconnect() : connect({ connector: injected() }))}
            className="gap-1.5 text-xs"
          >
            <Wallet className="w-3.5 h-3.5" />
            {isConnected && address ? `${address.slice(0, 6)}…${address.slice(-4)}` : "Connect Wallet"}
          </Button>
        </div>
      </div>

      {/* Economics bar */}
      <div className="flex items-center justify-center gap-4 py-2 border-b border-border/50 px-4">
        <span className="text-[9px] sm:text-[10px] text-muted-foreground text-center">
          Fee: 5% · Settlement: permissionless · Monad chainId 143
        </span>
      </div>

      {/* Market grid */}
      <div className="p-4 sm:p-6 grid grid-cols-1 md:grid-cols-3 gap-4 max-w-6xl mx-auto">
        {markets.map((m) => (
          <MarketCard
            key={m.address}
            market={m}
            walletReady={walletReady}
            onBet={onBet}
            selectedSide={selection[m.symbol]?.side ?? null}
            selectedAmount={selection[m.symbol]?.amount ?? null}
            setSelectedSide={(side) =>
              setSelection((prev) => ({ ...prev, [m.symbol]: { ...(prev[m.symbol] ?? {}), side } }))
            }
            setSelectedAmount={(amt) =>
              setSelection((prev) => ({ ...prev, [m.symbol]: { ...(prev[m.symbol] ?? {}), amount: amt } }))
            }
            clearSelection={() => setSelection((prev) => ({ ...prev, [m.symbol]: {} }))}
          />
        ))}
      </div>

      {/* Operator console */}
      {showOperator && isOperator && (
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className="max-w-6xl mx-auto px-4 sm:px-6 pb-6"
        >
          <div className="rounded-xl border border-primary/30 bg-card/60 backdrop-blur p-4">
            <h3 className="text-sm font-bold text-primary mb-2">Operator Console</h3>
            <div className="text-xs text-muted-foreground">
              Operator runs on Pi (creates + seeds markets, posts Pi pick). Keeper settles on VPS.
            </div>
          </div>
        </motion.div>
      )}

      <HackathonWarningModal isConnected={isConnected} />
    </div>
  );
}
